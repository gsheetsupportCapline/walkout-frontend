# Radio Button Sets - Complete Documentation

## Table of Contents

1. [Overview](#overview)
2. [Architecture](#architecture)
3. [Database Schema](#database-schema)
4. [API Endpoints](#api-endpoints)
5. [Use Cases and Examples](#use-cases-and-examples)
6. [Frontend Integration](#frontend-integration)
7. [Best Practices](#best-practices)

---

## Overview

The Radio Button Sets system provides a flexible infrastructure for managing radio button groups across the application. It implements an **embedded document architecture** where radio buttons are stored as subdocuments within their parent button sets.

### Key Features

- **Embedded Radio Buttons**: Buttons are stored as subdocuments within button sets (no separate collection)
- **Set-Based Organization**: All buttons belong to a specific button set
- **Role-Based Access Control**: Admin and SuperAdmin for mutations, all authenticated users for queries
- **Bulk Operations**: Efficient batch creation, updates, and deletions within a set
- **Visibility Control**: Buttons can be hidden without deletion
- **Name Uniqueness**: Button names must be unique within each set (can be reused across different sets)

### Design Philosophy

The system uses **embedded documents** for simplicity and atomic operations:

- Buttons are stored directly in the button set document
- No separate collection for radio buttons
- All CRUD operations happen within the parent set context
- Better performance for retrieving sets with their buttons
- Automatic cleanup when deleting a set (all buttons deleted together)

---

## Architecture

### Entity Relationship

```
┌──────────────────────────────────┐
│       ButtonSet Collection       │
├──────────────────────────────────┤
│ _id                              │
│ name (unique globally)           │
│ description                      │
│ isActive                         │
│ createdBy                        │
│ updatedBy                        │
│ buttons: [                       │
│   {                              │
│     _id (auto-generated)         │
│     name (unique within set)     │
│     visibility                   │
│     isActive                     │
│     createdAt                    │
│     updatedAt                    │
│   }                              │
│ ]                                │
└──────────────────────────────────┘
```

### Key Architectural Decisions

1. **Embedded Subdocuments**:
   - Radio buttons are embedded within button sets
   - No separate collection needed
   - Mongoose automatically generates `_id` for each button subdocument
2. **Set-Scoped Uniqueness**:
   - Button names must be unique within each set
   - Same button name can exist in different sets
   - Example: "Yes" button can exist in multiple sets
3. **Atomic Operations**:
   - Creating/updating/deleting buttons modifies the parent set document
   - MongoDB guarantees atomicity at document level
4. **Automatic Cleanup**:
   - Deleting a button set deletes all its buttons automatically
   - No orphaned button documents

---

## Database Schema

### ButtonSet Model

**Collection**: `button-sets`

```javascript
{
  _id: ObjectId,
  name: {
    type: String,
    required: true,
    unique: true,  // Globally unique across all button sets
    trim: true
  },
  description: {
    type: String,
    default: ""
  },
  lastButtonId: {
    type: Number,
    default: 0,
    // Counter for generating incremental IDs for buttons
  },
  buttons: [  // Embedded subdocuments
    {
      _id: ObjectId,  // Auto-generated by Mongoose
      incrementalId: {
        type: Number,
        required: true,
        // Unique within this set, never reused
      },
      name: {
        type: String,
        required: true,
        trim: true  // Must be unique within this set (enforced in controller)
      },
      visibility: {
        type: Boolean,
        default: true
      },
      isActive: {
        type: Boolean,
        default: true
      },
      createdAt: Date,
      updatedAt: Date
    }
  ],
  isActive: {
    type: Boolean,
    default: true
  },
  createdBy: {
    type: ObjectId,
    ref: "User",
    required: true
  },
  updatedBy: {
    type: ObjectId,
    ref: "User"
  },
  createdAt: Date,
  updatedAt: Date
}
```

**Indexes**:

- `name`: 1 (unique, auto-created)
- `isActive`: 1 (for filtering)

**Example Document**:

```json
{
  "_id": "6578abc123def456789012",
  "name": "Treatment Type",
  "description": "Types of dental treatments",
  "lastButtonId": 3,
  "buttons": [
    {
      "_id": "6578abc123def456789013",
      "incrementalId": 1,
      "name": "Cleaning",
      "visibility": true,
      "isActive": true,
      "createdAt": "2024-01-15T10:30:00.000Z",
      "updatedAt": "2024-01-15T10:30:00.000Z"
    },
    {
      "_id": "6578abc123def456789014",
      "incrementalId": 2,
      "name": "Filling",
      "visibility": true,
      "isActive": true,
      "createdAt": "2024-01-15T10:35:00.000Z",
      "updatedAt": "2024-01-15T10:35:00.000Z"
    },
    {
      "_id": "6578abc123def456789015",
      "incrementalId": 3,
      "name": "Root Canal",
      "visibility": false,
      "isActive": true,
      "createdAt": "2024-01-15T10:40:00.000Z",
      "updatedAt": "2024-01-15T14:20:00.000Z"
    }
  ],
  "isActive": true,
  "createdBy": "6578abc123def456789001",
  "updatedBy": "6578abc123def456789001",
  "createdAt": "2024-01-15T10:25:00.000Z",
  "updatedAt": "2024-01-15T14:20:00.000Z"
}
```

---

## Incremental ID System

### Purpose

Each radio button receives a unique **incremental ID** that is:

- **Never reused**: Even if a button is deleted, its incremental ID is never assigned to a new button
- **Sequential**: IDs increment from 1, 2, 3... within each button set
- **Stable**: Perfect for frontend mapping and tracking, unlike MongoDB's `_id` which changes on recreation

### How It Works

1. **ButtonSet Counter**: Each button set maintains a `lastButtonId` counter (starts at 0)
2. **Auto-Increment**: When creating a button, the counter increments: `lastButtonId += 1`
3. **Assignment**: The new value becomes the button's `incrementalId`
4. **Persistence**: The counter never decreases, even after deletions

### Schema Fields

```javascript
ButtonSet: {
  lastButtonId: {
    type: Number,
    default: 0,
    // Counter for generating incremental IDs
  }
}

RadioButton (subdocument): {
  incrementalId: {
    type: Number,
    required: true,
    // Unique within the parent button set
  }
}
```

### Example Flow

```javascript
// Initial state
ButtonSet: { lastButtonId: 0, buttons: [] }

// Create button "Cleaning"
lastButtonId: 0 → 1
Button: { incrementalId: 1, name: "Cleaning" }

// Create button "Filling"
lastButtonId: 1 → 2
Button: { incrementalId: 2, name: "Filling" }

// Create button "Root Canal"
lastButtonId: 2 → 3
Button: { incrementalId: 3, name: "Root Canal" }

// Delete button "Filling" (incrementalId: 2)
lastButtonId: stays at 3 (never decreases)
Buttons: [{ incrementalId: 1 }, { incrementalId: 3 }]

// Create new button "Extraction"
lastButtonId: 3 → 4
Button: { incrementalId: 4, name: "Extraction" }
// Note: incrementalId 2 is never reused!
```

### Benefits for Frontend

```javascript
// Frontend can safely map by incrementalId
const buttonMapping = {
  1: "Cleaning",
  3: "Root Canal",
  4: "Extraction",
  // ID 2 permanently retired
};

// When button name changes, incrementalId remains the same
// Frontend updates automatically without remapping
```

---

## Archive System

### Purpose

Instead of permanently deleting button sets or radio buttons, the system **archives** them to:

- **Preserve History**: Keep a record of all deleted items
- **Audit Trail**: Track who deleted what and when
- **Potential Recovery**: Ability to restore archived items (future feature)
- **Compliance**: Meet data retention requirements

### Archive Collection

**Collection**: `archive-radio-buttons`

```javascript
ArchiveRadioButton: {
  originalId: ObjectId,        // Original ButtonSet _id
  name: String,
  description: String,
  lastButtonId: Number,
  buttons: [                   // Archived button subdocuments
    {
      incrementalId: Number,
      name: String,
      visibility: Boolean,
      isActive: Boolean,
      originalId: ObjectId,    // Original button _id
      createdAt: Date,
      updatedAt: Date
    }
  ],
  isActive: Boolean,
  createdBy: ObjectId,
  updatedBy: ObjectId,

  // Deletion metadata
  deletedBy: ObjectId,         // Who deleted it
  deletedAt: Date,             // When it was deleted
  deletionReason: String,      // Why it was deleted (optional)

  // Original timestamps
  originalCreatedAt: Date,
  originalUpdatedAt: Date
}
```

### How It Works

#### Deleting a Button Set

1. **Archive Creation**: Copy entire button set to archive collection with deletion metadata
2. **Deletion**: Remove from main `button-sets` collection
3. **Result**: Users can't see it, but data is preserved in archive

```javascript
// Before deletion
ButtonSet: { _id: "abc123", name: "Treatment Type", buttons: [...] }

// After deletion
// Main collection: (deleted)
// Archive collection:
ArchiveRadioButton: {
  originalId: "abc123",
  name: "Treatment Type",
  buttons: [...],
  deletedBy: "user_id",
  deletedAt: "2024-12-20T10:00:00Z",
  deletionReason: "Manual deletion"
}
```

#### Deleting Individual Button

1. **Archive Creation**: Create archive entry with parent set info + only the deleted button
2. **Deletion**: Remove button subdocument from button set
3. **Result**: Button archived, set remains active with other buttons

```javascript
// Deleting button "Filling" from set "Treatment Type"
ArchiveRadioButton: {
  originalId: "set_abc123",           // Parent set ID
  name: "Treatment Type - Button: Filling",
  description: "Archived individual button from set: Treatment Type",
  buttons: [
    {
      incrementalId: 2,
      name: "Filling",
      originalId: "button_xyz789"      // Original button _id
    }
  ],
  deletedBy: "user_id",
  deletedAt: "2024-12-20T10:00:00Z",
  deletionReason: "Individual button deletion"
}
```

### Deletion Reason (Optional)

You can provide a deletion reason in the request body:

```json
DELETE /api/radio-buttons/button-sets/:id
{
  "deletionReason": "Service discontinued"
}
```

If not provided, defaults to "Manual deletion".

### Archive Queries (Future Feature)

Archive collections are indexed for efficient querying:

- By `originalId`: Find all archives for a specific set
- By `deletedBy`: See what a user deleted
- By `deletedAt`: Time-based queries
- By `name`: Search archived items

---

## API Endpoints

### Base URL

All radio button endpoints are prefixed with: `/api/radio-buttons`

### Authentication

All endpoints require JWT authentication via the `Authorization: Bearer <token>` header.

### Permission Levels

- **All Authenticated Users**: GET requests (read-only)
- **Admin & SuperAdmin**: POST, PUT, DELETE requests (mutations)

---

## 1. Button Set Endpoints

### 1.1 Create Button Set

**Endpoint**: `POST /api/radio-buttons/button-sets`

**Access**: Admin, SuperAdmin

**Description**: Creates a new button set with an empty buttons array.

**Request Body**:

```json
{
  "name": "Treatment Type",
  "description": "Types of dental treatments",
  "isActive": true
}
```

**Response** (201):

```json
{
  "success": true,
  "data": {
    "_id": "6578abc123def456789012",
    "name": "Treatment Type",
    "description": "Types of dental treatments",
    "buttons": [],
    "isActive": true,
    "createdBy": {
      "_id": "6578abc123def456789001",
      "name": "Admin User",
      "email": "admin@example.com"
    },
    "createdAt": "2024-01-15T10:25:00.000Z",
    "updatedAt": "2024-01-15T10:25:00.000Z"
  }
}
```

**Error Responses**:

- `400`: Missing required field (name)
- `400`: Duplicate set name (code: 11000)
- `401`: Unauthorized
- `403`: Forbidden

---

### 1.2 Get All Button Sets

**Endpoint**: `GET /api/radio-buttons/button-sets`

**Access**: All authenticated users

**Query Parameters**:

- `isActive` (optional): Filter by active status (true/false)
- `limit` (optional): Number of results per page (default: 10)
- `skip` (optional): Number of results to skip (default: 0)

**Example Request**:

```
GET /api/radio-buttons/button-sets?isActive=true&limit=20&skip=0
```

**Response** (200):

```json
{
  "success": true,
  "count": 2,
  "data": [
    {
      "_id": "6578abc123def456789012",
      "name": "Treatment Type",
      "description": "Types of dental treatments",
      "buttons": [
        {
          "_id": "6578abc123def456789013",
          "name": "Cleaning",
          "visibility": true,
          "isActive": true
        },
        {
          "_id": "6578abc123def456789014",
          "name": "Filling",
          "visibility": true,
          "isActive": true
        }
      ],
      "isActive": true,
      "createdBy": {
        "_id": "6578abc123def456789001",
        "name": "Admin User"
      },
      "createdAt": "2024-01-15T10:25:00.000Z",
      "updatedAt": "2024-01-15T14:20:00.000Z"
    }
  ]
}
```

---

### 1.3 Get Button Set by ID

**Endpoint**: `GET /api/radio-buttons/button-sets/:id`

**Access**: All authenticated users

**Response** (200):

```json
{
  "success": true,
  "data": {
    "_id": "6578abc123def456789012",
    "name": "Treatment Type",
    "description": "Types of dental treatments",
    "buttons": [
      {
        "_id": "6578abc123def456789013",
        "name": "Cleaning",
        "visibility": true,
        "isActive": true,
        "createdAt": "2024-01-15T10:30:00.000Z",
        "updatedAt": "2024-01-15T10:30:00.000Z"
      }
    ],
    "isActive": true,
    "createdBy": {
      "_id": "6578abc123def456789001",
      "name": "Admin User",
      "email": "admin@example.com"
    },
    "createdAt": "2024-01-15T10:25:00.000Z",
    "updatedAt": "2024-01-15T14:20:00.000Z"
  }
}
```

---

### 1.4 Update Button Set

**Endpoint**: `PUT /api/radio-buttons/button-sets/:id`

**Access**: Admin, SuperAdmin

**Description**: Updates button set properties (name, description, isActive). Does not modify buttons - use button-specific endpoints for that.

**Request Body** (all fields optional):

```json
{
  "name": "Treatment Type Updated",
  "description": "Updated description",
  "isActive": false
}
```

**Response** (200):

```json
{
  "success": true,
  "data": {
    "_id": "6578abc123def456789012",
    "name": "Treatment Type Updated",
    "description": "Updated description",
    "buttons": [...],
    "isActive": false,
    "updatedBy": {
      "_id": "6578abc123def456789002",
      "name": "SuperAdmin User"
    },
    "updatedAt": "2024-01-15T15:45:00.000Z"
  }
}
```

---

### 1.5 Delete Button Set

**Endpoint**: `DELETE /api/radio-buttons/button-sets/:id`

**Access**: Admin, SuperAdmin

**Description**: Permanently deletes a button set and all its embedded buttons.

**Response** (200):

```json
{
  "success": true,
  "message": "Button set deleted successfully"
}
```

---

## 2. Radio Button Endpoints (Embedded)

### 2.1 Create Radio Button

**Endpoint**: `POST /api/radio-buttons/button-sets/:buttonSetId/buttons`

**Access**: Admin, SuperAdmin

**Description**: Creates a new radio button within a specific button set.

**Request Body**:

```json
{
  "name": "Root Canal",
  "visibility": true,
  "isActive": true
}
```

**Response** (201):

```json
{
  "success": true,
  "data": {
    "_id": "6578abc123def456789012",
    "name": "Treatment Type",
    "buttons": [
      {
        "_id": "6578abc123def456789015",
        "name": "Root Canal",
        "visibility": true,
        "isActive": true,
        "createdAt": "2024-01-15T16:00:00.000Z",
        "updatedAt": "2024-01-15T16:00:00.000Z"
      }
    ],
    "updatedBy": {
      "_id": "6578abc123def456789001",
      "name": "Admin User"
    },
    "updatedAt": "2024-01-15T16:00:00.000Z"
  }
}
```

**Error Responses**:

- `400`: Missing button name
- `400`: Duplicate button name within the set
- `404`: Button set not found

---

### 2.2 Get All Buttons in Set

**Endpoint**: `GET /api/radio-buttons/button-sets/:buttonSetId/buttons`

**Access**: All authenticated users

**Query Parameters**:

- `isActive` (optional): Filter by active status
- `visibility` (optional): Filter by visibility

**Example Request**:

```
GET /api/radio-buttons/button-sets/6578abc123def456789012/buttons?isActive=true&visibility=true
```

**Response** (200):

```json
{
  "success": true,
  "count": 3,
  "data": [
    {
      "_id": "6578abc123def456789013",
      "name": "Cleaning",
      "visibility": true,
      "isActive": true,
      "createdAt": "2024-01-15T10:30:00.000Z",
      "updatedAt": "2024-01-15T10:30:00.000Z"
    },
    {
      "_id": "6578abc123def456789014",
      "name": "Filling",
      "visibility": true,
      "isActive": true,
      "createdAt": "2024-01-15T10:35:00.000Z",
      "updatedAt": "2024-01-15T10:35:00.000Z"
    }
  ]
}
```

---

### 2.3 Get Button by ID

**Endpoint**: `GET /api/radio-buttons/button-sets/:buttonSetId/buttons/:buttonId`

**Access**: All authenticated users

**Response** (200):

```json
{
  "success": true,
  "data": {
    "_id": "6578abc123def456789013",
    "name": "Cleaning",
    "visibility": true,
    "isActive": true,
    "createdAt": "2024-01-15T10:30:00.000Z",
    "updatedAt": "2024-01-15T10:30:00.000Z"
  }
}
```

---

### 2.4 Update Radio Button

**Endpoint**: `PUT /api/radio-buttons/button-sets/:buttonSetId/buttons/:buttonId`

**Access**: Admin, SuperAdmin

**Request Body** (all fields optional):

```json
{
  "name": "Deep Cleaning",
  "visibility": false,
  "isActive": true
}
```

**Response** (200):

```json
{
  "success": true,
  "data": {
    "_id": "6578abc123def456789012",
    "name": "Treatment Type",
    "buttons": [
      {
        "_id": "6578abc123def456789013",
        "name": "Deep Cleaning",
        "visibility": false,
        "isActive": true,
        "updatedAt": "2024-01-15T17:00:00.000Z"
      }
    ],
    "updatedBy": {
      "_id": "6578abc123def456789001",
      "name": "Admin User"
    }
  }
}
```

---

### 2.5 Delete Radio Button

**Endpoint**: `DELETE /api/radio-buttons/button-sets/:buttonSetId/buttons/:buttonId`

**Access**: Admin, SuperAdmin

**Response** (200):

```json
{
  "success": true,
  "message": "Button deleted successfully"
}
```

---

## 3. Bulk Operations

### 3.1 Bulk Create Buttons

**Endpoint**: `POST /api/radio-buttons/button-sets/:buttonSetId/buttons/bulk`

**Access**: Admin, SuperAdmin

**Request Body**:

```json
{
  "buttons": [
    {
      "name": "Cleaning",
      "visibility": true,
      "isActive": true
    },
    {
      "name": "Filling",
      "visibility": true,
      "isActive": true
    },
    {
      "name": "Extraction",
      "visibility": true,
      "isActive": true
    }
  ]
}
```

**Response** (201):

```json
{
  "success": true,
  "created": 3,
  "failed": 0,
  "data": {
    "_id": "6578abc123def456789012",
    "name": "Treatment Type",
    "buttons": [
      {
        "_id": "6578abc123def456789013",
        "name": "Cleaning",
        "visibility": true,
        "isActive": true
      },
      {
        "_id": "6578abc123def456789014",
        "name": "Filling",
        "visibility": true,
        "isActive": true
      },
      {
        "_id": "6578abc123def456789015",
        "name": "Extraction",
        "visibility": true,
        "isActive": true
      }
    ]
  },
  "errors": []
}
```

**Partial Success Example**:

```json
{
  "success": true,
  "created": 2,
  "failed": 1,
  "data": {...},
  "errors": [
    {
      "button": {
        "name": "Filling",
        "visibility": true,
        "isActive": true
      },
      "error": "Button with name 'Filling' already exists in this set"
    }
  ]
}
```

---

### 3.2 Bulk Update Buttons

**Endpoint**: `PUT /api/radio-buttons/button-sets/:buttonSetId/buttons/bulk`

**Access**: Admin, SuperAdmin

**Request Body**:

```json
{
  "updates": [
    {
      "id": "6578abc123def456789013",
      "name": "Deep Cleaning",
      "visibility": true
    },
    {
      "id": "6578abc123def456789014",
      "isActive": false
    }
  ]
}
```

**Response** (200):

```json
{
  "success": true,
  "updated": 2,
  "failed": 0,
  "data": {
    "_id": "6578abc123def456789012",
    "name": "Treatment Type",
    "buttons": [...]
  },
  "errors": []
}
```

---

### 3.3 Bulk Delete Buttons

**Endpoint**: `DELETE /api/radio-buttons/button-sets/:buttonSetId/buttons/bulk`

**Access**: Admin, SuperAdmin

**Request Body**:

```json
{
  "ids": ["6578abc123def456789013", "6578abc123def456789014"]
}
```

**Response** (200):

```json
{
  "success": true,
  "deleted": 2,
  "failed": 0,
  "message": "2 buttons deleted successfully",
  "errors": []
}
```

---

## Use Cases and Examples

### Use Case 1: Creating a Treatment Type Radio Button Set

**Step 1**: Create the button set

```bash
POST /api/radio-buttons/button-sets
{
  "name": "Treatment Type",
  "description": "Types of dental treatments"
}
```

**Step 2**: Add buttons to the set (bulk create)

```bash
POST /api/radio-buttons/button-sets/:buttonSetId/buttons/bulk
{
  "buttons": [
    {"name": "Cleaning", "visibility": true, "isActive": true},
    {"name": "Filling", "visibility": true, "isActive": true},
    {"name": "Root Canal", "visibility": true, "isActive": true},
    {"name": "Extraction", "visibility": true, "isActive": true}
  ]
}
```

**Result**: Button set created with 4 radio buttons embedded

---

### Use Case 2: Temporarily Hiding a Button

**Scenario**: "Root Canal" treatment is temporarily unavailable.

```bash
PUT /api/radio-buttons/button-sets/:buttonSetId/buttons/:buttonId
{
  "visibility": false
}
```

**Result**: Button remains in the set but hidden from users when filtering by `visibility: true`

---

### Use Case 3: Reusing Button Names Across Different Sets

**Scenario**: Need "Yes/No" buttons in multiple sets.

```bash
# Set 1: Insurance Coverage
POST /api/radio-buttons/button-sets
{"name": "Insurance Coverage"}

POST /api/radio-buttons/button-sets/:setId1/buttons/bulk
{"buttons": [{"name": "Yes"}, {"name": "No"}]}

# Set 2: Previous Treatment
POST /api/radio-buttons/button-sets
{"name": "Previous Treatment"}

POST /api/radio-buttons/button-sets/:setId2/buttons/bulk
{"buttons": [{"name": "Yes"}, {"name": "No"}]}
```

**Result**: "Yes" and "No" buttons exist in both sets independently

---

## Frontend Integration

### React Example: Fetching and Displaying Radio Buttons

```javascript
import React, { useState, useEffect } from "react";
import axios from "axios";

const RadioButtonSet = ({ buttonSetId }) => {
  const [buttonSet, setButtonSet] = useState(null);
  const [selectedButton, setSelectedButton] = useState("");
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const fetchButtonSet = async () => {
      try {
        const token = localStorage.getItem("authToken");
        const response = await axios.get(
          `http://localhost:5000/api/radio-buttons/button-sets/${buttonSetId}`,
          {
            headers: { Authorization: `Bearer ${token}` },
          }
        );

        setButtonSet(response.data.data);
        setLoading(false);
      } catch (error) {
        console.error("Failed to load button set:", error);
        setLoading(false);
      }
    };

    fetchButtonSet();
  }, [buttonSetId]);

  if (loading) return <div>Loading...</div>;
  if (!buttonSet) return null;

  // Filter visible and active buttons
  const visibleButtons = buttonSet.buttons.filter(
    (btn) => btn.visibility && btn.isActive
  );

  return (
    <div className="radio-button-set">
      <h3>{buttonSet.name}</h3>
      {buttonSet.description && <p>{buttonSet.description}</p>}

      <div className="radio-buttons">
        {visibleButtons.map((button) => (
          <label key={button._id} className="radio-label">
            <input
              type="radio"
              name={buttonSet._id}
              value={button._id}
              checked={selectedButton === button._id}
              onChange={(e) => setSelectedButton(e.target.value)}
            />
            {button.name}
          </label>
        ))}
      </div>
    </div>
  );
};

export default RadioButtonSet;
```

---

## Best Practices

### 1. Button Naming

- Use clear, descriptive names
- Keep names concise (under 50 characters)
- Use consistent capitalization
- Examples: "Cleaning", "Root Canal", "Filling"

### 2. Set Organization

- Create separate sets for different contexts
- Example: "Treatment Type" vs "Payment Method"
- Don't mix unrelated buttons in one set

### 3. Visibility vs Deletion

- **Use `visibility: false`** for temporary hiding (data preserved)
- **Use DELETE** only when button will never be used again
- Visibility allows easy restoration

### 4. Performance

- Button sets load all embedded buttons in one query (efficient)
- Use pagination when fetching multiple sets
- Filter by `isActive` and `visibility` on frontend

### 5. Uniqueness

- Button names must be unique **within each set**
- Same name can exist across different sets
- Set names must be globally unique

---

## Troubleshooting

**Issue**: Can't create button with existing name

**Solution**: Check if button name already exists in that specific set. Same name is allowed in different sets.

---

**Issue**: Deleted button set but need to restore buttons

**Solution**: Embedded documents are deleted with parent. Always backup before deleting sets. Consider using `isActive: false` instead of deletion.

---

**Issue**: Can't find button by ID

**Solution**: Button IDs are scoped to their parent set. Always provide both `buttonSetId` and `buttonId` in requests.

---

## API Summary

| Endpoint                                     | Method | Access     | Description            |
| -------------------------------------------- | ------ | ---------- | ---------------------- |
| `/button-sets`                               | POST   | Admin      | Create button set      |
| `/button-sets`                               | GET    | All        | Get all sets           |
| `/button-sets/:id`                           | GET    | All        | Get set by ID          |
| `/button-sets/:id`                           | PUT    | Admin      | Update set             |
| `/button-sets/:id`                           | DELETE | Admin      | Delete set             |
| `/button-sets/:setId/buttons`                | POST   | Admin      | Create button          |
| `/button-sets/:setId/buttons`                | GET    | All        | Get all buttons        |
| `/button-sets/:setId/buttons/:btnId`         | GET    | All        | Get button by ID       |
| `/button-sets/:setId/buttons/:btnId`         | PUT    | Admin      | Update button          |
| `/button-sets/:setId/buttons/:btnId`         | DELETE | Admin      | Delete button          |
| `/button-sets/:setId/buttons/bulk`           | POST   | Admin      | Bulk create            |
| `/button-sets/:setId/buttons/bulk`           | PUT    | Admin      | Bulk update            |
| `/button-sets/:setId/buttons/bulk`           | DELETE | Admin      | Bulk delete            |
| `/archives/button-sets`                      | GET    | SuperAdmin | Get archived sets      |
| `/archives/button-sets/:id`                  | GET    | SuperAdmin | Get archived set by ID |
| `/archives/button-sets/:archiveId/restore`   | POST   | SuperAdmin | Restore archived set   |
| `/archives/button-sets/:archiveId/permanent` | DELETE | SuperAdmin | Permanently delete     |

---

## Restore Operations (SuperAdmin Only)

### View Archived Button Sets

**Endpoint**: `GET /api/radio-buttons/archives/button-sets`

**Access**: SuperAdmin only

**Query Parameters**:

- `deletedBy`: Filter by user who deleted (ObjectId)
- `limit`: Number of results (default: 20)
- `skip`: Pagination offset (default: 0)
- `sortBy`: Sort field (default: "-deletedAt")

**Response** (200):

```json
{
  "success": true,
  "count": 2,
  "total": 5,
  "data": [
    {
      "_id": "archive123",
      "originalId": "6578abc123def456789012",
      "name": "Treatment Type",
      "description": "Select treatment type",
      "lastButtonId": 3,
      "buttons": [
        {
          "originalId": "btn001",
          "incrementalId": 1,
          "name": "Cleaning",
          "visibility": true,
          "isActive": true
        }
      ],
      "deletedBy": {
        "_id": "user123",
        "name": "Admin User",
        "email": "admin@example.com"
      },
      "deletedAt": "2024-01-20T10:00:00.000Z",
      "deletionReason": "Accidentally deleted"
    }
  ]
}
```

---

### Get Archived Button Set by ID

**Endpoint**: `GET /api/radio-buttons/archives/button-sets/:id`

**Access**: SuperAdmin only

**Response** (200):

```json
{
  "success": true,
  "data": {
    "_id": "archive123",
    "originalId": "6578abc123def456789012",
    "name": "Treatment Type",
    "buttons": [...],
    "deletedBy": {...},
    "deletedAt": "2024-01-20T10:00:00.000Z",
    "originalCreatedAt": "2024-01-15T10:00:00.000Z"
  }
}
```

---

### Restore Archived Button Set

**Endpoint**: `POST /api/radio-buttons/archives/button-sets/:archiveId/restore`

**Access**: SuperAdmin only

**Request Body** (optional):

```json
{
  "newName": "Treatment Type (Restored)" // Optional: rename if original name exists
}
```

**Response** (200):

```json
{
  "success": true,
  "message": "Button set restored successfully",
  "data": {
    "_id": "new_id_123",
    "name": "Treatment Type (Restored)",
    "lastButtonId": 3,
    "buttons": [
      {
        "_id": "new_btn_id",
        "incrementalId": 1,
        "name": "Cleaning",
        "visibility": true,
        "isActive": true
      }
    ],
    "createdBy": {...},
    "updatedBy": {...}  // User who performed restore
  }
}
```

**Error Response** (400) - Name Conflict:

```json
{
  "success": false,
  "message": "Button set with name 'Treatment Type' already exists. Please rename the existing set first or provide a new name."
}
```

---

### Permanently Delete Archived Set

**Endpoint**: `DELETE /api/radio-buttons/archives/button-sets/:archiveId/permanent`

**Access**: SuperAdmin only

**Response** (200):

```json
{
  "success": true,
  "message": "Archived button set permanently deleted"
}
```

---

**Last Updated**: December 2024
**Version**: 2.1.0 (With Restore Operations)
**Maintained By**: Walkout Backend Team
